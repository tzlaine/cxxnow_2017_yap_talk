<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Expression Templates Everywhere with C++14 and Yap</title>
        <meta name="author" content="Zach Laine">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <link rel="stylesheet" href="css/custom.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown=""
                         data-separator="^====+$"
                         data-separator-vertical="^----+$"
                         data-notes="^Note:">
                <script type="text/template">

## Expression Templates Everywhere with C++14 and Yap
### Zach Laine, C++Now 2017

----

## Outline
- Expression Template Primer
- Introducing Yap
- Lessons Learned

====================

## Part 0
### Expression Templates

----

Why use expression templates?

- Optimization
<!-- .element: class="fragment" data-fragment-index="1" -->
- Expressiveness
<!-- .element: class="fragment" data-fragment-index="2" -->

----

Example 1: Optimizing linear algebra

From the Eigen documentation:

```cpp
VectorXf a(50), b(50), c(50), d(50);
// fill in values ...
a = 3*b + 4*c + 5*d;
```

The naive implementation produces five temporaries, with three allocations,
and (re)-reads every element of each temporary.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

One could hand-write this only to read each value once, and to create no
temporaries:

```cpp
for(int i = 0; i < 50; ++i)
  a[i] = 3*b[i] + 4*c[i] + 5*d[i];
```
<!-- .element: class="fragment" data-fragment-index="1" -->

Eigen does this, and additionally generates SIMD code where possible.  The
use of SIMD indicates that this is not just sugar.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

Example 2: Making auto-differentiation code more expressive

----

```cpp
//f(x1,x2,x3) = -5*x1+sin(10)*x1+10*x2-x3/6
PNode* v5 = create_param_node(-5);
PNode* v10 = create_param_node(10);
PNode* v6 = create_param_node(6);
VNode* x1 = create_var_node();
VNode* x2 = create_var_node();
VNode* x3 = create_var_node();

OPNode* op1 = create_binary_op_node(OP_TIMES,v5,x1);   //op1 = v5*x1
OPNode* op2 = create_uary_op_node(OP_SIN,v10);         //op2 = sin(v10)
OPNode* op3 = create_binary_op_node(OP_TIMES,op2,x1);  //op3 = op2*x1
OPNode* op4 = create_binary_op_node(OP_PLUS,op1,op3);  //op4 = op1 + op3
OPNode* op5 = create_binary_op_node(OP_TIMES,v10,x2);  //op5 = v10*x2
OPNode* op6 = create_binary_op_node(OP_PLUS,op4,op5);  //op6 = op4+op5
OPNode* op7 = create_binary_op_node(OP_DIVID,x3,v6);   //op7 = x3/v6
OPNode* op8 = create_binary_op_node(OP_MINUS,op6,op7); //op8 = op6 - op7
x1->val = -1.9;
x2->val = 2;
x3->val = 5./6.;
list.push_back(x1);
list.push_back(x2);
list.push_back(x3);
```

----

```cpp
//f(x1,x2,x3) = -5*x1+sin(10)*x1+10*x2-x3/6
using namespace autodiff_placeholders;
to_auto_diff_node(
    -5 * 1_p + sin_(10) * 1_p + 10 * 2_p - 3_p / 6,
    list,
    -1.9,
    2,
    5./6.
);
```

This has the same effect, but is easy to read and write.

----

How do expression templates work?

Expressions are captured as objects, transformed, and evaluated.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### Capturing an Expression

```cpp
auto expr = 1_p + 3;
```

The type of this expression is:
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
my_expr<
    yap::expr_kind::plus,
    hana::tuple<
        my_expr<
            yap::expr_kind::terminal,
            hana::tuple<yap::placeholder<1ll> >
        >,
        my_expr<
            yap::expr_kind::terminal,
            hana::tuple<int>
        >
    >
>
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

`yap::print(expr)` produces:

```
expr<+>
    term<yap::placeholder<1ll>>[=1]
    term<int>[=3]
```

----

Using the captured expression, we can transform it:
```cpp
auto transformed_expr = yap::transform(expr, some_transform);
```

and/or evaluate it:
<!-- .element: class="fragment" data-fragment-index="1" -->
```cpp
std::cout << yap::evaluate(expr, 5); // prints "8"
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

The creation of an expression tree is done with function overloading
(especially the overloadable operators).

```cpp
template <yap::expr_kind Kind, typename Tuple>
struct my_expr
{
    // other members ...

    template <typename OtherType>
    my_expr<yap::expr_kind::plus, hana::tuple</* magic! */>>
    operator+ (OtherType && ot)
    {
        return /* more magic! */;
    }
};
```
<!-- .element: class="fragment" data-fragment-index="1" -->

Yap handles the magic bits for you.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

Since that `operator+()` returns an instantiation of `my_expr`, the result
also has an `operator+()` that works similarly:

```cpp
auto expr = yap::make_terminal<my_expr>(1) + 2 + 3 + /* ... */;
```
<!-- .element: class="fragment" data-fragment-index="1" -->

All those integers become wrapped as terminals -- the introduction of the
first Yap expression causes the entire expression to become a Yap expression.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

## The State of the Art

----

Option 1: Hand-rolled implementation

This is what almost all expression template libraries do today.
<!-- .element: class="fragment" data-fragment-index="1" -->

Option 2: Boost.Proto
<!-- .element: class="fragment" data-fragment-index="2" -->

Used in Boost fairly extensively; lots of other examples exist.
<!-- .element: class="fragment" data-fragment-index="3" -->

Option 3: Give up (don't use expression templates)
<!-- .element: class="fragment" data-fragment-index="4" -->

This is the most common result.
<!-- .element: class="fragment" data-fragment-index="5" -->

====================

## Part 1
### Introducing Yap

----

### Design Goals

1. Make expression templates easy to use.
<!-- .element: class="fragment" -->
2. Mimic the behavior of built-in expressions wherever possible (see #1).
<!-- .element: class="fragment" -->
3. Never require implicit operations/evaluations.
<!-- .element: class="fragment" -->
4. Provide the same functionality as Boost.Proto, requiring less user code.
<!-- .element: class="fragment" -->

----

## The Structure of Yap

----

## The Expression Concept

----

First, there is an enumeration `expr_kind` that contains all the different kinds of
Yap expressions:

<ul>
<li class="fragment" data-fragment-index="1">Expression-references (`expr_ref`)</li>
<li class="fragment" data-fragment-index="2">Terminals ("leaf nodes")</li>
<li class="fragment" data-fragment-index="3">The overloadable operators (`+`, `-=`, `[]`, etc.)</li>
<li class="fragment" data-fragment-index="4">Ternary-operator analogue (`if_else`)</li>
<li class="fragment" data-fragment-index="5">The call operator</li>
</ul>

<p class="fragment" data-fragment-index="6">Each expr_kind enumerator has a
fixed arity in [1, 3], except for the `expr_kind` `call`.</p>

----

### The Expression Concept

`E` is a type that models `Expression`; `e` is an object of type `E`; and
`Tuple` is an instantiation of `hana::tuple`.

| Expression     | Type       | Description                | Notes                            |
| -------------- |:----------:|:--------------------------:|:--------------------------------:|
| `E::kind`      |`expr_kind` | Kind of expression `E` is. | Compile-time constant.           |
| `e.elements`   |`Tuple`     | Child expressions of `e`   | Elements appropriate to `E::kind`. |

----

Most Yap function templates operate on `Expression`s.

<p class="fragment" data-fragment-index="1">A single Yap expression can
contain multiple different models of `Expression` within it.</p>

----

### The ExpressionTemplate Concept

A template models `ExpressionTemplate` if it, when instantiated with an
`expr_kind` and an appropriate tuple, forms an `Expression`.

<p class="fragment" data-fragment-index="1">Nearly every Yap function template
must be instantiated with an `ExpressionTemplate`.</p>

----

## Yap Features

----

Algorithms that operate on expression trees that model the `Expression`
concept.

----

### `evaluate()`

```cpp
template <typename Expr, typename ...T>
decltype(auto) evaluate (Expr && expr, T && ... t);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

<p class="fragment" data-fragment-index="2">Evaluates `expr` based on built-in
evaluation of the operators used (if any), with user-defined evaluations via
customization points.</p>

----

### `evaluate_as()`

```cpp
template <typename R, typename Expr, typename ...T>
decltype(auto) evaluate_as (Expr && expr, T && ... t);
```
<!-- .element: class="fragment" -->

<p class="fragment">Just like `evaluate()`, except that the evaluation hooks
into the `eval_expression_as()` customization point.</p>

<p class="fragment">By default, `eval_expression_as()` just does a normal
evaluation, and then `static_cast`s the result to `R`.</p>

<p class="fragment">If you want different behavior when evaluating an
expression as one of several types, customizing `eval_expression_as()` allows
that.</p>

----

### `transform()`

```cpp
template <typename Expr, typename Transform>
decltype(auto) transform (Expr && expr, Transform && transform);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

<p class="fragment" data-fragment-index="2">Takes an Expression and returns
something user-defined.  This may be an evaluation of `expr` (e.g. an `int`)
or an `Expression`.</p>

That bears repeating.
<!-- .element: class="fragment" data-fragment-index="3" -->

<p class="fragment" data-fragment-index="4">A call to `transform()` may
evaluate the expression.</p>

----

There are also many functions that return the nth value from an
`Expression`'s tuple, using a naming scheme and typesafety that is
kind-specific:

<ul>
<li class="fragment" data-fragment-index="1">`left()` and `right()` operate
only on binary expressions</li>
<li class="fragment" data-fragment-index="2">`callable()` and `argument()`
operate only on call expressions</li>
<li class="fragment" data-fragment-index="3">etc.</li>
</ul>

```cpp
auto expr = x + 1;
auto left = yap::left(expr); // Ok.
auto fn = yap::callable(expr); // Error; expr is not a call-expression.
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

There is a reference template `yap::expression` that models
ExpressionTemplate.

<p class="fragment" data-fragment-index="1">It provides en overload for every
operator, `if_else`, etc.</p>

It is useful for prototyping or quick-and-dirty uses of expression templates.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

Yap provides macros for easily creating custom ExpressionTemplates:

```cpp
template <yap::expr_kind Kind, typename Tuple>
struct lazy_vector_expr
{
    using this_type = lazy_vector_expr<Kind, Tuple>;

    static const yap::expr_kind kind = Kind;

    Tuple elements;

    BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(plus, this_type, ::lazy_vector_expr)
    BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(minus, this_type, ::lazy_vector_expr)

    // Note that this does not return an expression; it is greedily evaluated.
    auto operator[] (std::size_t n) const;
};
```

----

Yap has customization points that can be user-overridden to create implicit
evaluations and transformations.

```cpp
namespace user {

    struct number
    {
        double value;
    };

    // User-defined binary-plus!  With weird semantics!
    template <typename A, typename B>
    inline auto eval_plus (A a, B b)
    { return number{a.value - b.value}; }

}

// ...

auto expr = yap::make_terminal(user::number{1.0}) + user::number{1.0};
std::cout << yap::evaluate(expr).value; // prints 0.0
```

----

## Use Cases

----

### Case 0: Hello, world!

```cpp
#include <boost/yap/expression.hpp>

#include <iostream>


int main ()
{
    evaluate(yap::make_terminal(std::cout) << "Hello" << ',' << " world!\n");

    return 0;
}
```

This uses `yap::expression`, and so is probably cheating.

----

### Case 1: A simple calculator

```cpp
#include <boost/yap/expression.hpp>

#include <iostream>


int main ()
{
    using namespace yap::literals;

    // Displays "5"
    std::cout << evaluate( 1_p + 2.0, 3.0 ) << std::endl;

    // Displays "6"
    std::cout << evaluate( 1_p * 2_p, 3.0, 2.0 ) << std::endl;

    // Displays "0.5"
    std::cout << evaluate( (1_p - 2_p) / 2_p, 3.0, 2.0 ) << std::endl;

    return 0;
}
```

----

### Case 2: Adding a simple arity-check to our simple calculator

```cpp
    auto expr_1 = 1_p + 2.0;
    auto expr_1_fn = [expr_1](auto &&... args) {
        auto const arity = yap::transform(expr_1, get_arity{});
        static_assert(arity.value == sizeof...(args),
                      "Called with wrong number of args.");
        return evaluate(expr_1, args...);
    };

    auto expr_2 = 1_p * 2_p;
    auto expr_2_fn = [expr_2](auto &&... args) {
        auto const arity = yap::transform(expr_2, get_arity{});
        static_assert(arity.value == sizeof...(args),
                      "Called with wrong number of args.");
        return evaluate(expr_2, args...);
    };

    auto expr_3 = (1_p - 2_p) / 2_p;
    auto expr_3_fn = [expr_3](auto &&... args) {
        auto const arity = yap::transform(expr_3, get_arity{});
        static_assert(arity.value == sizeof...(args),
                      "Called with wrong number of args.");
        return evaluate(expr_3, args...);
    };
```

----

```cpp
    // Displays "5"
    std::cout << expr_1_fn(3.0) << std::endl;

    // Displays "6"
    std::cout << expr_2_fn(3.0, 2.0) << std::endl;

    // Displays "0.5"
    std::cout << expr_3_fn(3.0, 2.0) << std::endl;

    // Static-asserts with "Called with wrong number of args."
    //std::cout << expr_3_fn(3.0) << std::endl;

    // Static-asserts with "Called with wrong number of args."
    //std::cout << expr_3_fn(3.0, 2.0, 1.0) << std::endl;
```

----

```cpp
struct get_arity {
    template <long long I>
    hana::llong<I> operator() (yap::terminal_tag, yap::placeholder<I>)
    { return hana::llong_c<I>; }

    template <typename T>
    auto operator() (yap::terminal_tag, T &&)
    {
        using namespace hana::literals; return 0_c;
    }

    template <typename Expr>
    auto operator() (Expr const & expr)
    {
        return hana::maximum(hana::transform(
            expr.elements,
            [](auto const & element) {
                return yap::transform(element, get_arity{});
            }
        ));
    }
};
```

----

The `get_arity` Transform doesn't produce an Expression, and it does not have
to. Transforms may produce Expressions or arbitrary values. They may also have
arbitrary side effects, and may be stateful.

----

### Case 3: That thing from before

Remember how Eigen eliminated temporaries from an assignment to an expression?

```cpp
int main ()
{
    lazy_vector v1{std::vector<double>(4, 1.0)};
    lazy_vector v2{std::vector<double>(4, 2.0)};
    lazy_vector v3{std::vector<double>(4, 3.0)};

    double d1 = (v2 + v3)[2];
    std::cout << d1 << "\n";

    v1 += v2 - v3;
    std::cout << '{' << v1[0] << ',' << v1[1]
              << ',' << v1[2] << ',' << v1[3] << '}' << "\n";

    // This expression is disallowed because it does not conform to the
    // implicit grammar.  operator+= is only defined on terminals, not
    // arbitrary expressions.
    // (v2 + v3) += v1;

    return 0;
}
```

----

```cpp
// A custom expression template that defines lazy + and - operators that
// produce expressions, and an eager [] operator that returns the nth element
// of the expression.
template <yap::expr_kind Kind, typename Tuple>
struct lazy_vector_expr
{
    using this_type = lazy_vector_expr<Kind, Tuple>;

    static const yap::expr_kind kind = Kind;

    Tuple elements;

    BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(plus, this_type, ::lazy_vector_expr)
    BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(minus, this_type, ::lazy_vector_expr)

    // Note that this does not return an expression; it is greedily evaluated.
    auto operator[] (std::size_t n) const
    { return yap::evaluate(yap::transform(*this, take_nth{n})); }
};
```

----

```cpp
// This transform turns a terminal of std::vector<double> into a terminal
// containing the nth double in that vector.  Think of it as turning our
// expression of vectors into an expression of scalars.
struct take_nth
{
    yap::terminal<lazy_vector_expr, double>
    operator() (yap::terminal<lazy_vector_expr,
                              std::vector<double>> const & expr)
    {
        double x = yap::value(expr)[n];
        return yap::make_terminal<lazy_vector_expr, double>(std::move(x));
    }

    std::size_t n;
};
```

----

```cpp
// Define operator+= with the semantics we want, in a terminal
// instantiation of lazy_vector_expr.  We could have written a template
// specialization here instead, but that would require more typing.
struct lazy_vector :
    lazy_vector_expr<
        yap::expr_kind::terminal,
        hana::tuple<std::vector<double>>
    >
{
    explicit lazy_vector (std::vector<double> && vec)
    { elements = hana::tuple<std::vector<double>>(std::move(vec)); }

    template <yap::expr_kind Kind, typename Tuple>
    lazy_vector & operator+= (lazy_vector_expr<Kind, Tuple> const & rhs)
    {
        std::vector<double> & this_vec = yap::value(*this);
        for (int i = 0, size = (int)this_vec.size(); i < size; ++i) {
            this_vec[i] += rhs[i];
        }
        return *this;
    }
};
```

----

### How about code generation?

----

Here's the Linux x86-64 assembly code for

```cpp
double d1 = v2[2] + v3[2];
```

```
   mov    0x201329(%rip),%rax        # 0x602190 <v2>
   movsd  0x10(%rax),%xmm0
   mov    0x201335(%rip),%rax        # 0x6021a8 <v3>
   addsd  0x10(%rax),%xmm0
   retq   
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

And here it is for the Yap expression

```cpp
double d1 = (v2 + v3)[2];
```

```
   mov    0x201349(%rip),%rax        # 0x602190 <v2>
   movsd  0x10(%rax),%xmm0
   mov    0x201355(%rip),%rax        # 0x6021a8 <v3>
   addsd  0x10(%rax),%xmm0
   retq   
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

The temporary elimination that happens in

```
v1 += v2 - v3;
```

also produces the same assembly as the equivalent hand-written loop.

----

In this example, the terminal type owns the storage of its value, a
`std::vector<double>`.  Terminals may instead refer to values.

----

### Case 4: That thing from before

Remember the auto-diff example?  Instead of the very verbose form, we want to
write this function:

```cpp
Node* build_linear_fun1(vector<Node*>& list)
{
    //f(x1,x2,x3) = -5*x1+sin(10)*x1+10*x2-x3/6
    using namespace autodiff_placeholders;
    return to_auto_diff_node(
        -5 * 1_p + sin_(10) * 1_p + 10 * 2_p - 3_p / 6,
        list,
        -1.9,
        2,
        5./6.
    );
}
```

----

```cpp
template <yap::expr_kind Kind, typename Tuple>
struct autodiff_expr
{
  using this_type = autodiff_expr<Kind, Tuple>;

  static yap::expr_kind const kind = Kind;

  Tuple elements;

  BOOST_YAP_USER_UNARY_OPERATOR_MEMBER(negate, this_type, ::autodiff_expr)
  BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(plus, this_type, ::autodiff_expr)
  BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(minus, this_type, ::autodiff_expr)
  BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(multiplies, this_type, ::autodiff_expr)
  BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(divides, this_type, ::autodiff_expr)
};

BOOST_YAP_USER_FREE_BINARY_OPERATOR(plus, ::autodiff_expr)
BOOST_YAP_USER_FREE_BINARY_OPERATOR(minus, ::autodiff_expr)
BOOST_YAP_USER_FREE_BINARY_OPERATOR(multiplies, ::autodiff_expr)
BOOST_YAP_USER_FREE_BINARY_OPERATOR(divides, ::autodiff_expr)
```

----

```cpp
namespace autodiff_placeholders {

    // This defines a placeholder literal operator that creates autodiff_expr
    // placeholders.
    BOOST_YAP_USER_LITERAL_PLACEHOLDER_OPERATOR(autodiff_expr)

}
```

----

```cpp
template <OPCODE Opcode>
struct autodiff_fn_expr :
    autodiff_expr<yap::expr_kind::terminal, hana::tuple<OPCODE>>
{
    using this_type = autodiff_fn_expr<Opcode>;

    autodiff_fn_expr () :
        autodiff_expr {hana::tuple<OPCODE>{Opcode}}
    {}

    BOOST_YAP_USER_MEMBER_CALL_OPERATOR(this_type, ::autodiff_expr);
};

// Someone included <math.h>, so we have to add trailing underscores.
autodiff_fn_expr<OP_SIN> const sin_;
autodiff_fn_expr<OP_COS> const cos_;
autodiff_fn_expr<OP_SQRT> const sqrt_;
```

----

```cpp
struct xform
{
    // Create a var-node for each placeholder when we see it for the first
    // time.
    template <long long I>
    Node * operator() (yap::terminal_tag, yap::placeholder<I>)
    {
        if (list_.size() < I)
            list_.resize(I);
        auto & retval = list_[I - 1];
        if (retval == nullptr)
            retval = create_var_node();
        return retval;
    }
```

----

```cpp
    // Create a param-node for every numeric terminal in the expression.
    Node * operator() (yap::terminal_tag, double x)
    { return create_param_node(x); }

    // Just pass through the OPCODE within a function-terminal.
    OPCODE operator() (yap::terminal_tag, OPCODE opcode)
    { return opcode; }
```

----

```cpp
    // Create a "uary" node for each call expression, using its OPCODE.
    template <typename Expr>
    Node * operator() (yap::call_tag, OPCODE opcode, Expr const & expr)
    { return create_uary_op_node(opcode, yap::transform(expr, *this)); }

    template <typename Expr>
    Node * operator() (yap::negate_tag, Expr const & expr)
    { return create_uary_op_node(OP_NEG, yap::transform(expr, *this)); }
```

----

```cpp
    // Define a mapping from binary arothmetic tag type to OPCODE...
    static OPCODE op_for_tag (yap::plus_tag) { return OP_PLUS; }
    static OPCODE op_for_tag (yap::minus_tag) { return OP_MINUS; }
    static OPCODE op_for_tag (yap::multiplies_tag) { return OP_TIMES; }
    static OPCODE op_for_tag (yap::divides_tag) { return OP_DIVID; }
```

----

```cpp
    // ... and use it to handle all the binary arithmetic operators.
    template <typename Tag, typename Expr1, typename Expr2>
    Node * operator() (Tag tag, Expr1 const & expr1, Expr2 const & expr2)
    {
        return create_binary_op_node(
            op_for_tag(tag),
            yap::transform(expr1, *this),
            yap::transform(expr2, *this)
        );
    }

    vector<Node *> & list_;
};
```

----

```cpp
template <typename Expr, typename ...T>
Node * to_auto_diff_node (Expr const& expr, vector<Node *>& list, T ...args)
{
    Node * retval = nullptr;

    // This fills in list as a side effect.
    retval = yap::transform(expr, xform{list});

    // Fill in the values of the value-nodes in list with the "args"
    // parameter pack.
    auto it = list.begin();
    hana::for_each(
        hana::make_tuple(args ...),
        [&it](auto x) {
            Node * n = *it;
            VNode * v = polymorphic_downcast<VNode *>(n);
            v->val = x;
            ++it;
        }
    );

    return retval;
}
```

----

## Technicalities of Use

----

Yap makes every effort to make a Yap expression walk and quack just like like
a built-in expression.

----

- Types are partially decayed.
  - Array to pointer.
  <!-- .element: class="fragment" data-fragment-index="1" -->
  - Array reference to pointer.
  <!-- .element: class="fragment" data-fragment-index="2" -->
  - Function to function pointer.
  <!-- .element: class="fragment" data-fragment-index="3" -->

----

- Lvalues are captured in expressions by reference.

- Rvalues are treated as temporaries.
<!-- .element: class="fragment" data-fragment-index="1" -->
  - Rvalues are moved into, and owned by, the expression.
  <!-- .element: class="fragment" data-fragment-index="2" -->
  - Rvalues share the lifetime of the expression.
  <!-- .element: class="fragment" data-fragment-index="3" -->
  - make_terminal() should be called with a std::move'd value to force a value
  to be stored.
  <!-- .element: class="fragment" data-fragment-index="4" -->

----

For example:

```cpp
auto expr = a + 1;
```

<p class="fragment" data-fragment-index="1">Expect that `a` will be an lvalue
reference to some object of type `decltype(a)`, regardless of whether
`decltype(a)` is an `Expression` or a builtin type.</p>

<p class="fragment" data-fragment-index="2">Similarly, you should expect the
`1` to be represented in `expr` by a value.</p>

This is just what you would expect in any C++ expression.
<!-- .element: class="fragment" data-fragment-index="3" -->

----

This makes it easy to choose among copies, mutable refs and constant refs in
expressions -- just use the normal rules.


```cpp
int i = 0;
auto expr = boost::yap::make_terminal(i) = 42;
evaluate(expr);
std::cout << i << "\n"; // Prints 42.
```

----

### A Complication

Yap expressions can be built piecemeal:

```cpp
auto subexpr = boost::yap::make_terminal(1) + 2;
// This is fine, and acts more-or-less as if you wrote "1 / (1 + 2)".
auto expr = 1 / subexpr;
```

Builtin expressions cannot:

```cpp
auto subexpr = 1 + 2;    // Same as "int subexpr = 3;".  Hm.
auto expr = 1 / subexpr; // Same as "int expr = 0;" Arg.
```

----

R- and lvalueness of subexpressions are treated just like the r- and
lvalueness of terminals.

- Lvalue subexpressions are captured by reference.
<!-- .element: class="fragment" data-fragment-index="1" -->
  - Subexpression capture is done with the special expr_ref expression kind.
  <!-- .element: class="fragment" data-fragment-index="2" -->

- Rvalues are moved into the expression.
<!-- .element: class="fragment" data-fragment-index="3" -->

----

## `evaluate()` vs. `transform()`

----

`evaluate()`

- Must traverse the entire expression tree, evaluating every node.
<!-- .element: class="fragment" -->
- Picks up customization points almost exclusively via ADL.
<!-- .element: class="fragment" -->
- Is entirely implicit and pre-determined at the point of call.
<!-- .element: class="fragment" -->

`transform()`
<!-- .element: class="fragment" -->

- May traverse all or part of the expression tree.
<!-- .element: class="fragment" -->
- May return the original tree, a different expression tree, or a
value that is not an expression tree at all.
<!-- .element: class="fragment" -->
- Is explicit and may be modified at the point of call.
<!-- .element: class="fragment" -->

TODO: Examples of deep vs. shallow transforms.

----

### Value vs. Reference Terminals

Terminals may own/contain their values, or refer to them.

Using reference terminals and appropriately constrained nonmember operators
allows you to use Yap with arbitrary types non-intrusively.
<!-- .element: class="fragment" -->

----

### Define Free Operators on `std::vector`s

```cpp
// Define a type trait that identifies std::vectors.
template <typename T>
struct is_vec : std::false_type {};

template <typename T, typename A>
struct is_vec<std::vector<T, A>> : std::true_type {};
```

```cpp
// Define all the expression-returning numeric operators we need.  Each will
// accept any std::vector<> as any of its arguments, and then any value in the
// remaining argument, if any -- some of the operators below are unary.
BOOST_YAP_USER_UDT_ANY_BINARY_OPERATOR(plus, boost::yap::expression, is_vec);
BOOST_YAP_USER_UDT_ANY_BINARY_OPERATOR(minus, boost::yap::expression, is_vec);
// etc.
```
<!-- .element: class="fragment" -->

----

### Define `assign()`

```cpp
// Assigns some expression e to the given vector by evaluating e elementwise,
// to avoid temporaries and allocations.
template <typename T, typename Expr>
std::vector<T> & assign (std::vector<T> & vec, Expr const & e)
{
  decltype(auto) expr = boost::yap::as_expr(e);
  assert(equal_sizes(vec.size(), expr));
  for (std::size_t i = 0, size = vec.size(); i < size; ++i) {
    vec[i] = boost::yap::evaluate(boost::yap::transform(expr, take_nth{i}));
  }
  return vec;
}
```

----

```cpp
int main()
{
    int i;
    int const n = 10;
    std::vector<int> a,b,c,d;
    std::vector<double> e(n);

    for (i = 0; i < n; ++i)
    {
        a.push_back(i);
        b.push_back(2*i);
        c.push_back(3*i);
        d.push_back(i);
    }

    // After this point, no allocations occur.
```

----

```cpp
    assign(b, 2);
    assign(d, a + b * c);

    a += if_else(d < 30, b, c);

    assign(e, c);
    e += e - 4 / (c + 1);

    for (i = 0; i < n; ++i)
    {
        std::cout
            << " a(" << i << ") = " << a[i]
            << " b(" << i << ") = " << b[i]
            << " c(" << i << ") = " << c[i]
            << " d(" << i << ") = " << d[i]
            << " e(" << i << ") = " << e[i]
            << std::endl;
    }

    return 0;
}```

----

## The Macros

----

Nearly all the macros take an `expr_template`, the `ExpressionTemplate` used
to instantiate the result.

----

```cpp
#define BOOST_YAP_USER_UNARY_OPERATOR_MEMBER( /* ... */ )
```

Defines a unary operator as a set of three member function templates, each
with different qualifiers (e.g. `operator~()`).

----

```cpp
#define BOOST_YAP_USER_BINARY_OPERATOR_MEMBER( /* ... */ )
```

Defines a binary operator as a set of three member function templates, each
with different qualifiers (e.g. `operator/()`).

<p class="fragment">The resulting operators only match `Expressions` on the
left (since they are member functions), but match anything on the left.</p>

```cpp
auto expr = yap::make_terminal<my_expr>(1.0);

auto expr_2 = expr / expr; // Ok.
auto expr_3 = expr / 0;    // Ok.
auto expr_4 = 1 / expr;    // Error!  No such operator.
```
<!-- .element: class="fragment" -->

----

```cpp
#define BOOST_YAP_USER_MEMBER_CALL_OPERATOR( /* ... */ )
```

Defines a call operator as a set of three member function templates, each with
different qualifiers.

----

```cpp
#define BOOST_YAP_USER_FREE_BINARY_OPERATOR( /* ... */ )
```

Defines a binary operator as a set of two free function templates.

<p class="fragment">The first template matches anything a non-`Expression` on
the left, and an `Expression` lvalue on the right.</p>

<p class="fragment">The first template matches anything a non-`Expression` on
the left, and an `Expression` rvalue on the right.</p>

```cpp
auto expr = yap::make_terminal<my_expr>(1.0);

auto expr_2 = expr / expr;         // Error!  No such operator.
auto expr_3 = expr / 0;            // Error!  No such operator.
auto expr_4 = 1 / expr;            // Ok.
auto expr_5 = 1 / std::move(expr); // Ok.
```
<!-- .element: class="fragment" -->

----

```cpp
#define BOOST_YAP_USER_EXPR_IF_ELSE( /* ... */ )
```

Defines a function template that matches any given arguments, as long as one
of them is an `Expression`.

----

```cpp
#define BOOST_YAP_USER_UDT_ANY_IF_ELSE( /* ... */ )
```

Defines a function template that matches three non-`Expression` arguments, as
long as one of them matches the given type trait.

----

```cpp
#define BOOST_YAP_USER_UDT_UNARY_OPERATOR( /* ... */ )
```

Defines a function template that matches any single non-`Expression` argument
that matches the given type trait.

----

```cpp
#define BOOST_YAP_USER_UDT_UDT_BINARY_OPERATOR( /* ... */ )
```

Defines a function template that matches any two non-`Expression` arguments
that match the given left and right type traits.

----

```cpp
#define BOOST_YAP_USER_UDT_ANY_BINARY_OPERATOR( /* ... */ )
```

Defines a function template that matches any two non-`Expression` arguments,
as long as at least one matches the given type trait.

----

```cpp
#define BOOST_YAP_USER_LITERAL_PLACEHOLDER_OPERATOR( /* ... */ )
```

Defines a user defined literal template that creates literal placeholders
using the given `ExpressionTemplate`.

----

`BOOST_YAP_CONVERSION_OPERATOR_TEMPLATE`

This only applies to the reference `ExpressionTemplate` `yap::expression`.

```cpp
template <typename R>
operator R ()
{ return eval_expression_as(*this, hana::basic_type<R>{}); }
```
<!-- .element: class="fragment" -->

<p class="fragment">You may want to apply the same pattern to your own
`ExpressionTemplate`s</p>

... but probably not until we get concepts.
<!-- .element: class="fragment" -->

----

## Comparison to Boost.Proto

----

Caveat: I'm no Boost.Proto guru.

----

Proto must do everything implicitly, because of the lack of `auto` variable
declarations.

Yap allows you to do the same, if that matches your use case more closely, but
encourages you to do transformation and evaluation explicitly.
<!-- .element: class="fragment" -->

----

Proto uses explicit contexts to give meaning to expression trees.

With Yap, the context is the scope of the expression tree.
<!-- .element: class="fragment" -->

----

Proto and Yap differ in how expressions are customized.  Proto uses domains
and wrappers, Yap uses user-written expression templates.

----

Proto suffers from C++98-era metaprogramming compile times, and Yap does not.

----

There are many other differences, but those are the big ones.

====================

## Part 2
### Lessons learned

----

### Lesson 1:

A `static const` value like `expr_ref` is easier to use than a tag type in
C++17.

```cpp
if constexpr (kind == expr_kind::expr_ref) {
    return /* ... */;
} else if constexpr (kind == expr_kind::terminal) {
    return /* ... */;
} /* else ... */
```
<!-- .element: class="fragment" -->

----

### Lesson 2:

When writing complex template code in C++14, write it first in C++17, and then
back-port.

Counterintuitively, this saves a lot of time!
<!-- .element: class="fragment" -->

----

```cpp
template <typename T>
decltype(auto) value_impl (T && x)
{
    if constexpr (is_expr<T>::value) {
        using namespace hana::literals;
        constexpr expr_kind kind = remove_cv_ref_t<T>::kind;
        constexpr expr_arity arity = arity_of<kind>();
        if constexpr (kind == expr_kind::expr_ref) {
            return value_impl(deref(static_cast<T &&>(x)));
        } else if constexpr (arity == expr_arity::one) {
            if constexpr (std::is_lvalue_reference<T>{}) {
                return x.elements[0_c];
            } else {
                return std::move(x.elements[0_c]);
            }
        } else {
            return static_cast<T &&>(x);
        }
    } else {
        return static_cast<T &&>(x);
    }
}
```

----

```cpp
// Forward declaration.
template <typename T>
decltype(auto) value_impl (T && x);

// ...

template <typename T>
decltype(auto) value_impl (T && x)
{
  return detail::value_impl_t<T, detail::is_expr<T>::value>{}(
    static_cast<T &&>(x)
  );
}
```

----

```cpp
template <typename T, bool IsExpr>
struct value_impl_t
{
  decltype(auto) operator() (T && x)
  {
    constexpr expr_kind kind = detail::remove_cv_ref_t<T>::kind;
    constexpr detail::expr_arity arity = detail::arity_of<kind>();
    return value_expr_impl<
      T,
      kind == expr_kind::expr_ref,
      arity == detail::expr_arity::one,
      std::is_lvalue_reference<T>{}
    >{}(static_cast<T &&>(x));
  }
};

template <typename T>
struct value_impl_t<T, false>
{
  decltype(auto) operator() (T && x)
  { return static_cast<T &&>(x); }
};
```

----

```cpp
template <typename T, bool IsExprRef, bool TakeValue, bool IsLvalueRef>
struct value_expr_impl;

template <typename T, bool TakeValue, bool IsLvalueRef>
struct value_expr_impl<T, true, TakeValue, IsLvalueRef>
{
  decltype(auto) operator() (T && x)
  { return value_impl(yap::deref(static_cast<T &&>(x))); }
};

template <typename T>
struct value_expr_impl<T, false, true, true>
{
  decltype(auto) operator() (T && x)
  { return x.elements[hana::llong_c<0>]; }
};
```

----

```cpp
template <typename T>
struct value_expr_impl<T, false, true, false>
{
  decltype(auto) operator() (T && x)
  { return std::move(x.elements[hana::llong_c<0>]); }
};

template <typename T, bool IsLvalueRef>
struct value_expr_impl<T, false, false, IsLvalueRef>
{
  decltype(auto) operator() (T && x)
  { return static_cast<T &&>(x); }
};
```

----

### Lesson 3:

Customization points are problematic because of all that ADL.

<p class="fragment">To get different behaviors using `eval_plus()`, you must
use a different type or different namespace for each desired behavior.</p>

----

### Lesson 4:

Explicit transforms make for better code than implicit transforms.

```cpp
template <yap::expr_kind Kind, typename Tuple>
struct my_expr { /* ... */ };

struct matrix
{
    // ...
    template <typename Expr>
    matrix & operator= (Expr const & expr_1)
    {
        auto expr_2 = yap::transform(expr_1, transform_1{});
        auto expr_3 = yap::transform(expr_2, transform_2{});
        // etc...
        auto expr_N = yap::transform(expr_N_minus_1, transform_N_minus_1{});

        *this = yap::evaluate_as<matrix>(expr_N);
    }
};
```

----

Wrapping `*this` in a terminal may eliminate the temporary, but you get the
idea.

====================

## Questions?

<span class="fragment fade-in">
https://github.com/tzlaine/yap <br>
</span>

                </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <!-- Required for the sampler.js plugin -->
        <script src="lib/js/jquery.min.js"></script>

        <script>
            Reveal.initialize({
                slideNumber: false, // 'c/t' -> useful when authoring to know how many slides there are
                history: true,
                transition: 'none',

                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/math/math.js', async: true },
                    { src: 'plugin/sampler/sampler.js' },
                    { src: 'plugin/line-numbers/line-numbers.js' }
                ]
            });

            // By marking a slide with <!-- .slide: data-state="ensure-sbs" -->,
            // the presentation is re-scaled so that two side-by-side code
            // snippets can fit. By using data-state="end-sbs", the
            // presentation is scaled back to its original width.
            // This is super hacky, but I suck at JavaScript.
            Reveal.addEventListener('ensure-sbs', function() {
              Reveal.configure({ width: '150%' });
            }, false);

            Reveal.addEventListener('end-sbs', function() {
              Reveal.configure({ width: 960 });
            }, false);

            // Slides marked with <!-- .slide: class="skip" --> will
            // be hidden from the presentation. This is handy for removing
            // material that I think I won't have time to cover, but without
            // removing the slide.
            Reveal.addEventListener('ready', function(event) {
              $(".slides .skip").each(function(index, slide) {
                slide.remove();
              });
              Reveal.sync();
            });
        </script>
    </body>
</html>
