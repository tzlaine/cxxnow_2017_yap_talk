<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Expression Templates Everywhere with C++14 and Yap</title>
        <meta name="author" content="Zach Laine">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <link rel="stylesheet" href="css/custom.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown=""
                         data-separator="^====+$"
                         data-separator-vertical="^----+$"
                         data-notes="^Note:">
                <script type="text/template">

## Expression Templates Everywhere with C++14 and Yap
### Zach Laine, C++Now 2017

====================

## Outline
- Expression Template Primer
- Introducing Yap
- Lessons Learned

====================

## Part 0
### Expression Templates

----

Why use expression templates?

- Optimization
<!-- .element: class="fragment" data-fragment-index="1" -->
- Expressiveness
<!-- .element: class="fragment" data-fragment-index="2" -->

----

Example 1: Optimizing linear algebra

From the Eigen documentation:

```cpp
VectorXf a(50), b(50), c(50), d(50);
// fill in values ...
a = 3*b + 4*c + 5*d;
```

The naive implementation produces five temporaries, with three allocations,
and (re)-reads every element of each temporary.

----

One could hand-write this only to read each value once, and to create no
temporaries:

```cpp
for(int i = 0; i < 50; ++i)
  a[i] = 3*b[i] + 4*c[i] + 5*d[i];
```

Eigen does this, and additionally generates SIMD code where possible.  The
use of SIMD indicates that this is not just sugar.

----

Example 2: Making auto-differentiation code more expressive

----

```cpp
//f(x1,x2,x3) = -5*x1+sin(10)*x1+10*x2-x3/6
PNode* v5 = create_param_node(-5);
PNode* v10 = create_param_node(10);
PNode* v6 = create_param_node(6);
VNode*	x1 = create_var_node();
VNode*	x2 = create_var_node();
VNode*	x3 = create_var_node();

OPNode* op1 = create_binary_op_node(OP_TIMES,v5,x1);   //op1 = v5*x1
OPNode* op2 = create_uary_op_node(OP_SIN,v10);         //op2 = sin(v10)
OPNode* op3 = create_binary_op_node(OP_TIMES,op2,x1);  //op3 = op2*x1
OPNode* op4 = create_binary_op_node(OP_PLUS,op1,op3);  //op4 = op1 + op3
OPNode*	op5 = create_binary_op_node(OP_TIMES,v10,x2);  //op5 = v10*x2
OPNode* op6 = create_binary_op_node(OP_PLUS,op4,op5);  //op6 = op4+op5
OPNode* op7 = create_binary_op_node(OP_DIVID,x3,v6);   //op7 = x3/v6
OPNode* op8 = create_binary_op_node(OP_MINUS,op6,op7); //op8 = op6 - op7
x1->val = -1.9;
x2->val = 2;
x3->val = 5./6.;
list.push_back(x1);
list.push_back(x2);
list.push_back(x3);
```

----

```cpp
//f(x1,x2,x3) = -5*x1+sin(10)*x1+10*x2-x3/6
using namespace autodiff_placeholders;
to_auto_diff_node(
    -5 * 1_p + sin_(10) * 1_p + 10 * 2_p - 3_p / 6,
    list,
    -1.9,
    2,
    5./6.
);
```

This has the same effect, but is easy to read and write.

----

How do expression templates work?

Expressions are captured as objects, transformed, and evaluated.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### Capturing an Expression

```cpp
auto expr = 1_p + 3;
```

The type of this expression is:
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
my_expr<
    yap::expr_kind::plus,
    hana::tuple<
        my_expr<
            yap::expr_kind::terminal,
            hana::tuple<yap::placeholder<1ll> >
        >,
        my_expr<
            yap::expr_kind::terminal,
            hana::tuple<int>
        >
    >
>
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

`yap::print(expr)` produces:

```
expr<+>
    term<yap::placeholder<1ll>>[=1]
    term<int>[=3]
```

----

Using the captured expression, we can transform it:
```cpp
auto transformed_expr = yap::transform(expr, some_transform);
```

and/or evaluate it:
<!-- .element: class="fragment" data-fragment-index="1" -->
```cpp
std::cout << yap::evaluate(expr, 5); // prints "8"
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

## The State of the Art

----

Option 1: Hand-rolled implementation

This is what almost all expression template libraries do today.
<!-- .element: class="fragment" data-fragment-index="1" -->

Option 2: Boost.Proto
<!-- .element: class="fragment" data-fragment-index="2" -->

Used in Boost fairly extensively; lots of other examples exist.
<!-- .element: class="fragment" data-fragment-index="3" -->

Option 3: Give up (don't use expression templates)
<!-- .element: class="fragment" data-fragment-index="4" -->

This is the most common result.
<!-- .element: class="fragment" data-fragment-index="5" -->

====================

## Part 1
### Introducing Yap

----

## Design Goals

1. Make expression templates easy to use.
<!-- .element: class="fragment" data-fragment-index="1" -->
2. Mimic the behavior built-in expression wherever possible (see #1).
<!-- .element: class="fragment" data-fragment-index="2" -->
3. Never require implicit operations/evaluations.
<!-- .element: class="fragment" data-fragment-index="3" -->

----

## The Structure of Yap

----

## The Expression Concept

----

First, there is an enumeration `expr_kind` that contains all the different kinds of
Yap expressions:

<ul>
<li class="fragment" data-fragment-index="1">Expression-references (`expr_ref`)</li>
<li class="fragment" data-fragment-index="2">Terminals ("leaf nodes")</li>
<li class="fragment" data-fragment-index="3">The overloadable operators (`+`, `-=`, `[]`, etc.)</li>
<li class="fragment" data-fragment-index="4">Ternary-operator analogue (`if_else`)</li>
<li class="fragment" data-fragment-index="5">The call operator</li>
</ul>

<p class="fragment" data-fragment-index="6">Each expr_kind enumerator has a
fixed arity in [1, 3], except for the call `expr_kind`.</p>

----

## The Expression Concept

`E` is a type that models `Expression`; `e` is an object of type `E`; and
`Tuple` is an instantiation of `hana::tuple`.

| Expression     | Type       | Description                | Notes                            |
| -------------- |:----------:|:--------------------------:|:--------------------------------:|
| `E::kind`      |`expr_kind` | Kind of expression `E` is. | Compile-time constant.           |
| `e.elements`   |`Tuple`     | Child expressions of `e`   | Elements appropriate to `E::kind`. |

<p class="fragment" data-fragment-index="1">Most Yap function templates
operate on `Expression`s.</p>

<p class="fragment" data-fragment-index="2">A single Yap expressions can
contain multiple different models of `Expression` within it.</p>

----

## The ExpressionTemplate Concept

A template models `ExpressionTemplate` if it, when instantiated with an
`expr_kind` and an appropriate tuple, forms an `Expression`.

<p class="fragment" data-fragment-index="1">Nearly every Yap function template
must be instantiated with an `ExpressionTemplate`.</p>

----

## Yap Features

----

Algorithms that operate on expression trees that model the `Expression`
concept.

```cpp
template <typename Expr, typename ...T>
decltype(auto) evaluate (Expr && expr, T && ... t);
```
<!-- .element: class="fragment" data-fragment-index="1" -->

<p class="fragment" data-fragment-index="2">Evaluates `expr` based on built-in
evaluation of the operators used (if any), with user-defined evaluations via
customization points.</p>

----

```cpp
template <typename Expr, typename Transform>
decltype(auto) transform (Expr && expr, Transform && transform);
```

Takes an Expression and returns something user-defined.  This may be an
evaluation of `expr` (e.g. an `int`) or an `Expression`.

That bears repeating.
<!-- .element: class="fragment" data-fragment-index="1" -->

<p class="fragment" data-fragment-index="2">A call to `transform()` may
evaluate the expression.</p>

----

There are also many functions that return the nth value from an
`Expression`'s tuple, using a naming scheme and typesafety that is
kind-specific:

<ul>
<li class="fragment" data-fragment-index="1">`left()` and `right()` operate
only on binary expressions</li>
<li class="fragment" data-fragment-index="2">`callable()` and `argument()`
operate only on call expressions</li>
<li class="fragment" data-fragment-index="3">etc.</li>
</ul>

```cpp
auto expr = x + 1;
auto left = yap::left(expr); // Ok.
auto fn = yap::callable(expr); // Error; expr is not a call-expression.
```
<!-- .element: class="fragment" data-fragment-index="4" -->

----

There is a reference template `yap::expression` that models
ExpressionTemplate.

<p class="fragment" data-fragment-index="1">It provides en overload for every
operator, `if_else`, etc.</p>

It is useful for prototyping or quick-and-dirty uses of expression templates.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

Yap provides macros for easily creating custom ExpressionTemplates:

```cpp
template <yap::expr_kind Kind, typename Tuple>
struct lazy_vector_expr
{
    using this_type = lazy_vector_expr<Kind, Tuple>;

    static const yap::expr_kind kind = Kind;

    Tuple elements;

    BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(plus, this_type, ::lazy_vector_expr)
    BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(minus, this_type, ::lazy_vector_expr)

    // Note that this does not return an expression; it is greedily evaluated.
    auto operator[] (std::size_t n) const;
};
```

----

Yap has customization points that can be user-overridden to create implicit
evaluations and transformations.

```cpp
namespace user {

    struct number
    {
        double value;
    };

    // User-defined binary-plus!  With weird semantics!
    template <typename A, typename B>
    inline auto eval_plus (A a, B b)
    { return number{a.value - b.value}; }

}

// ...

auto expr = yap::make_terminal(user::number{1.0}) + user::number{1.0};
std::cout << yap::evaluate(expr).value; // prints 0.0
```

----

## Use Cases

----

### Case 0: Hello, world!

```cpp
#include <boost/yap/expression.hpp>

#include <iostream>


int main ()
{
    evaluate(yap::make_terminal(std::cout) << "Hello" << ',' << " world!\n");

    return 0;
}
```

This uses `yap::expression`, and so is probably cheating.

----

### Case 1: A simple calculator

```cpp
#include <boost/yap/expression.hpp>

#include <iostream>


int main ()
{
    using namespace yap::literals;

    // Displays "5"
    std::cout << evaluate( 1_p + 2.0, 3.0 ) << std::endl;

    // Displays "6"
    std::cout << evaluate( 1_p * 2_p, 3.0, 2.0 ) << std::endl;

    // Displays "0.5"
    std::cout << evaluate( (1_p - 2_p) / 2_p, 3.0, 2.0 ) << std::endl;

    return 0;
}
```

----

### Case 2: Adding a simple arity-check to our simple calculator

```cpp
    auto expr_1 = 1_p + 2.0;
    auto expr_1_fn = [expr_1](auto &&... args) {
        auto const arity = yap::transform(expr_1, get_arity{});
        static_assert(arity.value == sizeof...(args),
                      "Called with wrong number of args.");
        return evaluate(expr_1, args...);
    };

    auto expr_2 = 1_p * 2_p;
    auto expr_2_fn = [expr_2](auto &&... args) {
        auto const arity = yap::transform(expr_2, get_arity{});
        static_assert(arity.value == sizeof...(args),
                      "Called with wrong number of args.");
        return evaluate(expr_2, args...);
    };

    auto expr_3 = (1_p - 2_p) / 2_p;
    auto expr_3_fn = [expr_3](auto &&... args) {
        auto const arity = yap::transform(expr_3, get_arity{});
        static_assert(arity.value == sizeof...(args),
                      "Called with wrong number of args.");
        return evaluate(expr_3, args...);
    };
```

----

```cpp
    // Displays "5"
    std::cout << expr_1_fn(3.0) << std::endl;

    // Displays "6"
    std::cout << expr_2_fn(3.0, 2.0) << std::endl;

    // Displays "0.5"
    std::cout << expr_3_fn(3.0, 2.0) << std::endl;

    // Static-asserts with "Called with wrong number of args."
    //std::cout << expr_3_fn(3.0) << std::endl;

    // Static-asserts with "Called with wrong number of args."
    //std::cout << expr_3_fn(3.0, 2.0, 1.0) << std::endl;
```

----

```cpp
struct get_arity {
    template <long long I>
    hana::llong<I> operator() (yap::terminal_tag, yap::placeholder<I>)
    { return hana::llong_c<I>; }

    template <typename T>
    auto operator() (yap::terminal_tag, T &&)
    {
        using namespace hana::literals; return 0_c;
    }

    template <typename Expr>
    auto operator() (Expr const & expr)
    {
        return hana::maximum(hana::transform(
            expr.elements,
            [](auto const & element) {
                return yap::transform(element, get_arity{});
            }
        ));
    }
};
```

----

The `get_arity` Transform doesn't produce an Expression, and it does not have
to. Transforms may produce Expressions or arbitrary values. They may also have
arbitrary side effects, and may be stateful.

----

### Case 3: That thing from before

Remember how Eigen eliminated temporaries from an assignment to an expression?

```cpp
int main ()
{
    lazy_vector v1{std::vector<double>(4, 1.0)};
    lazy_vector v2{std::vector<double>(4, 2.0)};
    lazy_vector v3{std::vector<double>(4, 3.0)};

    double d1 = (v2 + v3)[2];
    std::cout << d1 << "\n";

    v1 += v2 - v3;
    std::cout << '{' << v1[0] << ',' << v1[1]
              << ',' << v1[2] << ',' << v1[3] << '}' << "\n";

    // This expression is disallowed because it does not conform to the
    // implicit grammar.  operator+= is only defined on terminals, not
    // arbitrary expressions.
    // (v2 + v3) += v1;

    return 0;
}
```

----

```cpp
// A custom expression template that defines lazy + and - operators that
// produce expressions, and an eager [] operator that returns the nth element
// of the expression.
template <yap::expr_kind Kind, typename Tuple>
struct lazy_vector_expr
{
    using this_type = lazy_vector_expr<Kind, Tuple>;

    static const yap::expr_kind kind = Kind;

    Tuple elements;

    BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(plus, this_type, ::lazy_vector_expr)
    BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(minus, this_type, ::lazy_vector_expr)

    // Note that this does not return an expression; it is greedily evaluated.
    auto operator[] (std::size_t n) const
    { return yap::evaluate(yap::transform(*this, take_nth{n})); }
};
```

----

```cpp
// This transform turns a terminal of std::vector<double> into a terminal
// containing the nth double in that vector.  Think of it as turning our
// expression of vectors into an expression of scalars.
struct take_nth
{
    yap::terminal<lazy_vector_expr, double>
    operator() (yap::terminal<lazy_vector_expr,
                              std::vector<double>> const & expr)
    {
        double x = yap::value(expr)[n];
        return yap::make_terminal<lazy_vector_expr, double>(std::move(x));
    }

    std::size_t n;
};
```

----

```cpp
// Define operator+= with the semantics we want, in a terminal
// instantiation of lazy_vector_expr.  We could have written a template
// specialization here instead, but that would require more typing.
struct lazy_vector :
    lazy_vector_expr<
        yap::expr_kind::terminal,
        hana::tuple<std::vector<double>>
    >
{
    explicit lazy_vector (std::vector<double> && vec)
    { elements = hana::tuple<std::vector<double>>(std::move(vec)); }

    template <yap::expr_kind Kind, typename Tuple>
    lazy_vector & operator+= (lazy_vector_expr<Kind, Tuple> const & rhs)
    {
        std::vector<double> & this_vec = yap::value(*this);
        for (int i = 0, size = (int)this_vec.size(); i < size; ++i) {
            this_vec[i] += rhs[i];
        }
        return *this;
    }
};
```

----

### How about code generation?

----

Here's the Linux x86-64 assembly code for `double d1 = v2[2] + v3[2]`:

```
   mov    0x201329(%rip),%rax        # 0x602190 <v2>
   movsd  0x10(%rax),%xmm0
   mov    0x201335(%rip),%rax        # 0x6021a8 <v3>
   addsd  0x10(%rax),%xmm0
   retq   
```

----

And here it is for the Yap expression `double d1 = (v2 + v3)[2]`:

```
   mov    0x201349(%rip),%rax        # 0x602190 <v2>
   movsd  0x10(%rax),%xmm0
   mov    0x201355(%rip),%rax        # 0x6021a8 <v3>
   addsd  0x10(%rax),%xmm0
   retq   
```

----

The temporary elimination that happens in `v1 += v2 - v3` also produces the
same assembly as the equivalent hand-written loop.

----

In this example, the terminal type owns the storage of its value, a
`std::vector<double>`.  Terminals may instead refer to values.

----

### Case 4: That thing from before

Remember the auto-diff example?  Instead of the very verbose form, we want to
write this function:

```cpp
Node* build_linear_fun1(vector<Node*>& list)
{
    //f(x1,x2,x3) = -5*x1+sin(10)*x1+10*x2-x3/6
    using namespace autodiff_placeholders;
    return to_auto_diff_node(
        -5 * 1_p + sin_(10) * 1_p + 10 * 2_p - 3_p / 6,
        list,
        -1.9,
        2,
        5./6.
    );
}
```

----

```cpp
template <yap::expr_kind Kind, typename Tuple>
struct autodiff_expr
{
  using this_type = autodiff_expr<Kind, Tuple>;

  static yap::expr_kind const kind = Kind;

  Tuple elements;

  BOOST_YAP_USER_UNARY_OPERATOR_MEMBER(negate, this_type, ::autodiff_expr)
  BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(plus, this_type, ::autodiff_expr)
  BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(minus, this_type, ::autodiff_expr)
  BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(multiplies, this_type, ::autodiff_expr)
  BOOST_YAP_USER_BINARY_OPERATOR_MEMBER(divides, this_type, ::autodiff_expr)
};

BOOST_YAP_USER_FREE_BINARY_OPERATOR(plus, ::autodiff_expr)
BOOST_YAP_USER_FREE_BINARY_OPERATOR(minus, ::autodiff_expr)
BOOST_YAP_USER_FREE_BINARY_OPERATOR(multiplies, ::autodiff_expr)
BOOST_YAP_USER_FREE_BINARY_OPERATOR(divides, ::autodiff_expr)
```

----

```cpp
namespace autodiff_placeholders {

    // This defines a placeholder literal operator that creates autodiff_expr
    // placeholders.
    BOOST_YAP_USER_LITERAL_PLACEHOLDER_OPERATOR(autodiff_expr)

}
```

----

```cpp
template <OPCODE Opcode>
struct autodiff_fn_expr :
    autodiff_expr<yap::expr_kind::terminal, hana::tuple<OPCODE>>
{
    using this_type = autodiff_fn_expr<Opcode>;

    autodiff_fn_expr () :
        autodiff_expr {hana::tuple<OPCODE>{Opcode}}
    {}

    BOOST_YAP_USER_MEMBER_CALL_OPERATOR(this_type, ::autodiff_expr);
};

// Someone included <math.h>, so we have to add trailing underscores.
autodiff_fn_expr<OP_SIN> const sin_;
autodiff_fn_expr<OP_COS> const cos_;
autodiff_fn_expr<OP_SQRT> const sqrt_;
```

----

```cpp
struct xform
{
    // Create a var-node for each placeholder when we see it for the first
    // time.
    template <long long I>
    Node * operator() (yap::terminal_tag, yap::placeholder<I>)
    {
        if (list_.size() < I)
            list_.resize(I);
        auto & retval = list_[I - 1];
        if (retval == nullptr)
            retval = create_var_node();
        return retval;
    }
```

----

```cpp
    // Create a param-node for every numeric terminal in the expression.
    Node * operator() (yap::terminal_tag, double x)
    { return create_param_node(x); }

    // Just pass through the OPCODE within a function-terminal.
    OPCODE operator() (yap::terminal_tag, OPCODE opcode)
    { return opcode; }
```

----

```cpp
    // Create a "uary" node for each call expression, using its OPCODE.
    template <typename Expr>
    Node * operator() (yap::call_tag, OPCODE opcode, Expr const & expr)
    { return create_uary_op_node(opcode, yap::transform(expr, *this)); }

    template <typename Expr>
    Node * operator() (yap::negate_tag, Expr const & expr)
    { return create_uary_op_node(OP_NEG, yap::transform(expr, *this)); }
```

----

```cpp
    // Define a mapping from binary arothmetic tag type to OPCODE...
    static OPCODE op_for_tag (yap::plus_tag) { return OP_PLUS; }
    static OPCODE op_for_tag (yap::minus_tag) { return OP_MINUS; }
    static OPCODE op_for_tag (yap::multiplies_tag) { return OP_TIMES; }
    static OPCODE op_for_tag (yap::divides_tag) { return OP_DIVID; }
```

----

```cpp
    // ... and use it to handle all the binary arithmetic operators.
    template <typename Tag, typename Expr1, typename Expr2>
    Node * operator() (Tag tag, Expr1 const & expr1, Expr2 const & expr2)
    {
        return create_binary_op_node(
            op_for_tag(tag),
            yap::transform(expr1, *this),
            yap::transform(expr2, *this)
        );
    }

    vector<Node *> & list_;
};
```

----

```cpp
template <typename Expr, typename ...T>
Node * to_auto_diff_node (Expr const& expr, vector<Node *>& list, T ...args)
{
    Node * retval = nullptr;

    // This fills in list as a side effect.
    retval = yap::transform(expr, xform{list});

    // Fill in the values of the value-nodes in list with the "args"
    // parameter pack.
    auto it = list.begin();
    hana::for_each(
        hana::make_tuple(args ...),
        [&it](auto x) {
            Node * n = *it;
            VNode * v = polymorphic_downcast<VNode *>(n);
            v->val = x;
            ++it;
        }
    );

    return retval;
}
```

----

## Technicalities of Use

----

Yap makes every effort to make a Yap expression walk and quack just like like
a built-in expression.

----

- Values are partially decayed.
  - Array to pointer.
  <!-- .element: class="fragment" data-fragment-index="1" -->
  - Array reference to pointer.
  <!-- .element: class="fragment" data-fragment-index="2" -->
  - Function to function pointer.
  <!-- .element: class="fragment" data-fragment-index="3" -->

----

- Lvalues are captured in expressions by reference

- Rvalues are treated as temporaries.
<!-- .element: class="fragment" data-fragment-index="1" -->
  - Rvalues are copied into, and owned by, the expression.
  <!-- .element: class="fragment" data-fragment-index="2" -->
  - Rvalues share the lifetime of the expression.
  <!-- .element: class="fragment" data-fragment-index="3" -->
  - make_terminal() should be called with a std::move'd value to force a value
  to be stored.
  <!-- .element: class="fragment" data-fragment-index="4" -->

----

For example:

```
auto expr = a + 1;
```

<p class="fragment" data-fragment-index="1">Expect that `a` will be an lvalue
reference to some object of type `decltype(a)`, regardless of whether
`decltype(a)` is an `Expression` or a builtin type.</p>

<p class="fragment" data-fragment-index="2">Similarly, you should expect the
`1` to be an rvalue.</p>

This is just what you would expect in any C++ expression.
<!-- .element: class="fragment" data-fragment-index="3" -->

----

This makes it easy to choose among copies, mutable refs and constant refs in
expressions -- just use the normal rules.


```
int i = 0;
auto expr = boost::yap::make_terminal(i) = 42;
evaluate(expr);
std::cout << i << "\n"; // Prints 42.
```

----

Yap expressions can be built piecemeal:

```
auto subexpr = boost::yap::make_terminal(1) + 2;
// This is fine, and acts more-or-less as if you wrote "1 / (1 + 2)".
auto expr = 1 / subexpr;
```

Builtin expressions cannot:

```
auto subexpr = 1 + 2;    // Same as "int subexpr = 3;".  Hm.
auto expr = 1 / subexpr; // Same as "int expr = 0;" Arg.
```

----

R- and lvalueness of subexpressions are treated just like terminals.

- Lvalues are captured by reference.
<!-- .element: class="fragment" data-fragment-index="1" -->
  - Subexpression capture is done with the special expr_ref expression kind.
  <!-- .element: class="fragment" data-fragment-index="2" -->

- Rvalues are moved into the expression.
<!-- .element: class="fragment" data-fragment-index="3" -->

----

- evaluating transforms, and the inherent difference between transforms and evaluations
- owning vs. unowning terminals
- placeholders
- else_if
- member function vs. free function macros
- conversion operator template

TODO

----

## Comparison to Boost.Proto

TODO

====================

## Part 2
### Lessons learned

TODO: expr_kind is better than a tag type because of constexpr if.

----

## Experience Using constexpr if

TODO

----

## Pluses And Minuses of Customization Points

TODO

----

## Explicit vs. Implicit Customization Techniques

TODO

====================

## Questions?

<span class="fragment fade-in">
https://github.com/tzlaine/yap <br>
</span>

                </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <!-- Required for the sampler.js plugin -->
        <script src="lib/js/jquery.min.js"></script>

        <script>
            Reveal.initialize({
                slideNumber: false, // 'c/t' -> useful when authoring to know how many slides there are
                history: true,
                transition: 'none',

                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/math/math.js', async: true },
                    { src: 'plugin/sampler/sampler.js' },
                    { src: 'plugin/line-numbers/line-numbers.js' }
                ]
            });

            // By marking a slide with <!-- .slide: data-state="ensure-sbs" -->,
            // the presentation is re-scaled so that two side-by-side code
            // snippets can fit. By using data-state="end-sbs", the
            // presentation is scaled back to its original width.
            // This is super hacky, but I suck at JavaScript.
            Reveal.addEventListener('ensure-sbs', function() {
              Reveal.configure({ width: '150%' });
            }, false);

            Reveal.addEventListener('end-sbs', function() {
              Reveal.configure({ width: 960 });
            }, false);

            // Slides marked with <!-- .slide: class="skip" --> will
            // be hidden from the presentation. This is handy for removing
            // material that I think I won't have time to cover, but without
            // removing the slide.
            Reveal.addEventListener('ready', function(event) {
              $(".slides .skip").each(function(index, slide) {
                slide.remove();
              });
              Reveal.sync();
            });
        </script>
    </body>
</html>
